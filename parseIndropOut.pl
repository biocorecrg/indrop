#! /usr/bin/env perl 

=head1 NAME

=head1 SYNOPSIS

  perl parseIndropOut.pl [-file MatrixMarket file] [-o prefix output parsed file]  [-mingenes minimum number of gene per cell] [-mintags minimum number of tags per gene] [-h help]

=head1 DESCRIPTION

  This script parses a matrixMarket file generated by indrop pipeline and filter the results according to some params.
  It also make a graph for further clustering suitable for MCL

  
Typical usage is as follows:

  % perl parseIndropOut.pl -file input.est.mtx  -o output parsed -mingenes 10 -mintags 1
  
=head2 Options

The following options are accepted:

 --file=<mtx name>   	(Mandatory).

 --mingenes=<symbol>		  			An integer (default 0)

 --mintags=<symbol>		  			An integer (default 0)

 --o=<file>		  		Output prefix (default output)

 --help                   	This documentation.


=head1 AUTHOR

Luca Cozzuto <luca.cozzuto@crg.es> 

=cut
use warnings;
use strict;
use Data::Dumper;
use File::Basename;
use Pod::Usage;
use Getopt::Long;
use List::Util 'sum';
use List::MoreUtils qw(uniq);

my $USAGE = "  perl parseIndropOut.pl [-file] [-o]  [-mingenes] [-mintags] [-h help]
";

my ($input,$output,$mingenes,$mintags,$show_help);

&GetOptions(    	
			'file|f=s'		=> \$input,
			'output|o=s'	=> \$output,
			'mingenes|mg=s'		=> \$mingenes,
			'mintags|mt=s'		=> \$mintags,
			'help|h'        => \$show_help
			)
  or pod2usage(-verbose=>2);
pod2usage(-verbose=>2) if $show_help;

if (!$output) { $output = "output"}
if (!$input) { die ("Please specify input file")}
if (!$mintags) { $mintags = 0}
if (!$mingenes) { $mingenes = 0};

#READ MTX FILE
my %hash;
my $numrow = 0;
my $totGenes = 0;
my $totCells = 0;
my $outfile	 = $output."_parsed.mtx";

open(my $fh, "<", $input)
	or die "Can't open < $input: $!";

while (my $row = <$fh>) {
	$numrow++;
	chomp $row;
	if ($numrow==2) {
		my @fields = split(" ", $row);
		$totGenes=$fields[0];
		$totCells=$fields[1];

	}
	elsif ($numrow>2) { 
		my @fields = split(" ", $row);
		my $geneID = $fields[0];
		my $CellID = $fields[1];
		my $tagCount = $fields[2];
		if ($tagCount >= $mintags) {
			$hash{$CellID}{$geneID} = $tagCount;
		}		
	}
}
close($fh);

my %genes;


foreach my $cellID (keys (%hash)) {
	my $outfile = $cellID.".genes";
	open(my $fw, ">", $outfile)
		or die "Can't open > $outfile: $!";

    my %propGenes;
	my $numgenes = scalar (keys ($hash{$cellID}));
	if ($numgenes >= $mingenes) {
		my $sumtags = sum(values $hash{$cellID});	
		foreach my $geneID (sort {$a <=> $b} keys $hash{$cellID}) {
		    my $tagCount = $hash{$cellID}{$geneID};
		    my $tagProp  = $hash{$cellID}{$geneID}/$sumtags;
			print $fw $geneID." ".$tagCount."\n";
			if ($tagProp>=0.01) {
				$propGenes{$cellID}{$geneID} = $geneID;
			}
			#print "cell".$cellID." gene".$geneID." ".$tagProp."\n";
		}
	}
	close($fw);
	#print Dumper \%propGenes;
} 

# my %comphash = %hash;
# foreach my $cellIDA (keys (%hash)) {
# 	foreach my $cellIDB (keys (%comphash)) {	
# 		if ($cellIDA ne $cellIDB) {
# 		    my @keys = uniq(keys($hash{$cellIDA}), keys($comphash{$cellIDB}));
# 		    my $listA = "";
# 		    my $listB = "";
# 		    foreach my $key (@keys) {
# 		    	$listA .= getVal($hash{$cellIDA}, $key).",";
# 		    	$listB .= getVal($hash{$cellIDB}, $key).",";
# 		    }
# 			$listA = substr($listA, 0, -1);
# 			$listB = substr($listB, 0, -1);
# 			my @res = split (" ", `./calc_dist.R \"$listA\" \"$listB\"`);
# 			#print Dumper sort $hash{$cellIDA};
# 			print $cellIDA." ".$cellIDB." ".$res[1]."\n";
# 			#print $cellIDA." ".$cellIDB."\n";
# 		}
# 	}
# }

# sub getVal {
# 	my ($hashRef, $id) = @_;
# 	my %hash = %{$hashRef};
# 	my $val = 0;
# 	if ($hash{$id}) {
# 		$val = $hash{$id};
# 	}
# 	return $val;
# }


